name: release

run-name: release for ${{ inputs.bump }}

on:
  workflow_dispatch:
    inputs:
      bump:
        type: choice
        description: Bump Target
        default: "build"
        options:
          - patch
          - minor
          - major

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}-${{ inputs.bump }}
  cancel-in-progress: true

jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4

      - uses: actions/github-script@v7
        id: release
        env:
          bump: ${{ inputs.bump }}
        with:
          result-encoding: string
          script: |
            const { bump } = process.env
            console.log(`Hello ${bump}.`)

            function log(message) {
              console.log(message);
            }

            function logError(error) {
              console.error('Error:', error);
              core.setFailed(error);
            }

            let latestRelease;
            try {
              const result = await github.rest.repos.getLatestRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
              });
              latestRelease = result.data.tag_name;
              log(`Latest release: ${latestRelease}`);
            }
            catch (error) {
              logError(`Failed to get latest release: ${error.message}`);
              return;
            }

            function bumpVersion(version, bump) {
              const hasPrefix = version.startsWith('v');
              const strippedVersion = hasPrefix ? version.substring(1) : version;

              let [major, minor, patch] = strippedVersion.split('.').map(num => parseInt(num, 10));

              switch (bump) {
                case 'major':
                  major += 1;
                  minor = 0;
                  patch = 0;
                  break;
                case 'minor':
                  minor += 1;
                  patch = 0;
                  break;
                case 'patch':
                  patch += 1;
                  break;
                default:
                  throw new Error('Invalid bump type');
              }

              return hasPrefix ? `v${major}.${minor}.${patch}` : `${major}.${minor}.${patch}`;
            }

            const newRelease = bumpVersion(latestRelease, bump);
            log(`New release: ${newRelease}`);

            // create tag
            try {
              await github.rest.git.createRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `refs/tags/${newRelease}`,
                sha: context.sha
              });
            }
            catch (error) {
              logError(`Failed to create tag: ${error.message}`);
              return;
            }

            try {
              await github.rest.repos.createRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_name: newRelease,
                generate_release_notes: true,
              });
            }
            catch (error) {
              logError(`Failed to create release: ${error.message}`);
              return;
            }

            const newMajor = newRelease.substring(0, newRelease.indexOf('.'));
            log(`New major: ${newMajor}`);

            return newMajor

      - run: |
          git config --local user.name $GIT_USER_NAME
          git config --local user.email $GIT_USER_EMAIL
          git tag -f "${{steps.release.outputs.result}}"
          git push -f origin "${{steps.release.outputs.result}}"
        env:
          GIT_USER_EMAIL: "41898282+github-actions[bot]@users.noreply.github.com"
          GIT_USER_NAME: "github-actions[bot]"
